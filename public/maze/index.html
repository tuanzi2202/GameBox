<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>è¿·å®«å¤§ä½œæˆ˜ (Fix v2)</title>
    <style>
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        body { 
            margin: 0; background: #000; color: #fff; overflow: hidden; 
            width: 100vw; height: 100dvh; /* ä½¿ç”¨ dvh é€‚é…æ‰‹æœº */
            display: flex; font-family: 'Segoe UI', sans-serif;
        }

        #canvas-wrapper { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 1;
        }

        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px;
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            z-index: 10;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }

        .back-btn { 
            pointer-events: auto;
            background: rgba(231, 76, 60, 0.9); padding: 8px 16px; border-radius: 20px; 
            font-size: 14px; font-weight: bold; box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
            backdrop-filter: blur(4px); cursor: pointer; border: 1px solid rgba(255,255,255,0.2);
        }

        .status-panel {
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px;
            font-size: 12px; color: #ccc; backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1); text-align: right;
        }

        #virtual-controls {
            position: absolute; bottom: 20px; left: 20px;
            display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px);
            gap: 5px; pointer-events: auto; 
            opacity: 0.5; transition: opacity 0.3s;
            transform: scale(0.7); transform-origin: bottom left; 
        }
        #virtual-controls:active { opacity: 0.9; }
        .v-btn {
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: #fff;
        }
        #vb-up { grid-column: 2; grid-row: 1; }
        #vb-left { grid-column: 1; grid-row: 2; }
        #vb-right { grid-column: 3; grid-row: 2; }
        #vb-down { grid-column: 2; grid-row: 3; }

        #message-overlay {
            position: absolute; top: 35%; width: 100%; text-align: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 20;
        }
        #message-overlay h1 { 
            font-size: 40px; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin: 0;
            -webkit-text-stroke: 1px rgba(0,0,0,0.8);
        }

        #portrait-warning {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; justify-content: center; align-items: center;
            flex-direction: column; text-align: center;
        }
        @media screen and (orientation: portrait) { #portrait-warning { display: flex; } }
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h2 style="color:#f1c40f;">ğŸ“± è¯·æ—‹è½¬æ‰‹æœº</h2>
        <p style="color:#666;">æ¨ªå±æ¸¸ç©ä½“éªŒæ›´ä½³</p>
    </div>

    <div id="canvas-wrapper"><canvas id="gameCanvas"></canvas></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="back-btn" onclick="location.href='../index.html'">â¬… é€€å‡º</div>
            <div class="status-panel">
                <div style="color: #2ecc71; font-size: 14px; font-weight: bold; margin-bottom: 4px;">ç›®æ ‡ï¼šç»¿è‰²å…‰æŸ±</div>
                <div id="conn-status">è¿æ¥ä¸­...</div>
            </div>
        </div>

        <div id="message-overlay">
            <h1 id="win-text">èƒœåˆ©ï¼</h1>
            <p style="color:#fff; text-shadow:0 0 5px #000;">å³å°†å¼€å§‹æ–°ä¸€å±€...</p>
        </div>

        <div id="virtual-controls">
            <div class="v-btn" id="vb-up">â–²</div>
            <div class="v-btn" id="vb-left">â—€</div>
            <div class="v-btn" id="vb-right">â–¶</div>
            <div class="v-btn" id="vb-down">â–¼</div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io('/maze'); 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');
        const msgOverlay = document.getElementById('message-overlay');
        const connStatus = document.getElementById('conn-status');

        let gameState = { maze: [], players: {}, startPoint: {}, endPoint: {} };
        let selfId = null;
        let gridSize = 30; 
        let CELL_SIZE = 40; 
        
        let playersRender = {}; 
        let camera = { x: 0, y: 0 };
        
        // ğŸ”¥ ä¿®å¤2ï¼šå®¢æˆ·ç«¯é˜²æŠ–èŠ‚æµ
        // å…è®¸æŒ‰ä½é”®ç›˜ï¼Œä½†é™åˆ¶å‘é€é¢‘ç‡ï¼Œé˜²æ­¢å‘åŒ…è¿‡å¿«å¯¼è‡´çš„å¡é¡¿
        let lastMoveTime = 0;
        const MOVE_INTERVAL = 90; // æ¯«ç§’ï¼Œç•¥å¤§äºæœåŠ¡å™¨çš„80msï¼Œä¿è¯é¡ºæ»‘

        function resize() {
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            draw();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if(!selfId || !gameState.players[selfId] || !gameState.maze.length) return;

            let me = gameState.players[selfId];
            let myRender = playersRender[selfId] || {x: me.gridX*CELL_SIZE, y: me.gridY*CELL_SIZE};
            
            // æ‘„åƒæœºé€»è¾‘
            let targetCamX = myRender.x + CELL_SIZE/2 - canvas.width/2;
            let targetCamY = myRender.y + CELL_SIZE/2 - canvas.height/2;
            let mapW = gridSize * CELL_SIZE;
            let mapH = gridSize * CELL_SIZE;
            
            if (mapW > canvas.width) targetCamX = Math.max(0, Math.min(targetCamX, mapW - canvas.width));
            else targetCamX = -(canvas.width - mapW) / 2;
            
            if (mapH > canvas.height) targetCamY = Math.max(0, Math.min(targetCamY, mapH - canvas.height));
            else targetCamY = -(canvas.height - mapH) / 2;

            camera.x += (targetCamX - camera.x) * 0.15; // ç¨å¾®è°ƒå¿«ä¸€ç‚¹è·Ÿéšé€Ÿåº¦
            camera.y += (targetCamY - camera.y) * 0.15;

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // ç»˜åˆ¶è¿·å®«
            let startCol = Math.floor(camera.x / CELL_SIZE);
            let endCol = startCol + (canvas.width / CELL_SIZE) + 1;
            let startRow = Math.floor(camera.y / CELL_SIZE);
            let endRow = startRow + (canvas.height / CELL_SIZE) + 1;

            ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 3; ctx.lineCap = 'round';
            ctx.shadowBlur = 10; ctx.shadowColor = '#00f3ff';

            ctx.beginPath();
            for(let y = Math.max(0, startRow-1); y < Math.min(gridSize, endRow+1); y++) {
                for(let x = Math.max(0, startCol-1); x < Math.min(gridSize, endCol+1); x++) {
                    let c = gameState.maze[y][x];
                    if (!c) continue; 
                    let px=x*CELL_SIZE, py=y*CELL_SIZE;
                    if(c.walls.bottom) { ctx.moveTo(px, py+CELL_SIZE); ctx.lineTo(px+CELL_SIZE, py+CELL_SIZE); }
                    if(c.walls.right) { ctx.moveTo(px+CELL_SIZE, py); ctx.lineTo(px+CELL_SIZE, py+CELL_SIZE); }
                    if(y===0 && c.walls.top) { ctx.moveTo(px, py); ctx.lineTo(px+CELL_SIZE, py); }
                    if(x===0 && c.walls.left) { ctx.moveTo(px, py); ctx.lineTo(px, py+CELL_SIZE); }
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ç»ˆç‚¹
            let ex = gameState.endPoint.x * CELL_SIZE;
            let ey = gameState.endPoint.y * CELL_SIZE;
            ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
            ctx.fillRect(ex+4, ey+4, CELL_SIZE-8, CELL_SIZE-8);
            ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 2;
            ctx.strokeRect(ex+2, ey+2, CELL_SIZE-4, CELL_SIZE-4);

            // ç©å®¶
            for(let id in gameState.players) {
                let p = gameState.players[id];
                if(!playersRender[id]) playersRender[id] = { x: p.gridX*CELL_SIZE, y: p.gridY*CELL_SIZE };
                
                let pr = playersRender[id];
                pr.x += (p.gridX*CELL_SIZE - pr.x) * 0.3; // æ¸²æŸ“è¿½èµ¶é€Ÿåº¦åŠ å¿«
                pr.y += (p.gridY*CELL_SIZE - pr.y) * 0.3;

                let cx = pr.x + CELL_SIZE/2;
                let cy = pr.y + CELL_SIZE/2;
                
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(cx, cy, CELL_SIZE*0.35, 0, Math.PI*2); ctx.fill();
                
                if(id === selfId) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath(); ctx.arc(cx, cy, CELL_SIZE*0.6, 0, Math.PI*2); ctx.fill();
                }
            }
            ctx.restore(); 

            // è¿·é›¾ä¸UI
            let playerScreenX = myRender.x + CELL_SIZE/2 - camera.x;
            let playerScreenY = myRender.y + CELL_SIZE/2 - camera.y;
            
            let grd = ctx.createRadialGradient(playerScreenX, playerScreenY, CELL_SIZE*2.5, playerScreenX, playerScreenY, CELL_SIZE*8);
            grd.addColorStop(0, "rgba(0,0,0,0)"); 
            grd.addColorStop(1, "rgba(0,0,0,0.98)");
            ctx.fillStyle = grd; ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawArrow(playerScreenX, playerScreenY);
        }

        function drawArrow(px, py) {
            let ex = gameState.endPoint.x * CELL_SIZE + CELL_SIZE/2 - camera.x;
            let ey = gameState.endPoint.y * CELL_SIZE + CELL_SIZE/2 - camera.y;
            let dx = ex - px, dy = ey - py;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > Math.min(canvas.width, canvas.height)/2) {
                let angle = Math.atan2(dy, dx);
                let radius = Math.min(canvas.width, canvas.height)/2 - 50;
                let arrowX = canvas.width/2 + Math.cos(angle) * radius;
                let arrowY = canvas.height/2 + Math.sin(angle) * radius;
                ctx.save();
                ctx.translate(arrowX, arrowY);
                ctx.rotate(angle);
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.moveTo(12, 0); ctx.lineTo(-12, 12); ctx.lineTo(-12, -12); ctx.fill();
                ctx.restore();
            }
        }

        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ğŸ”¥ ä¿®å¤1ï¼šæ ¸å¿ƒç§»åŠ¨é€»è¾‘ (å¸¦ç¢°æ’æ£€æµ‹)
        function attemptMove(dir) {
            if(!selfId || !gameState.players[selfId] || gameState.winner) return;
            
            // èŠ‚æµæ£€æŸ¥ï¼šé˜²æ­¢å‘åŒ…å¤ªå¿«
            const now = Date.now();
            if (now - lastMoveTime < MOVE_INTERVAL) return;

            let p = gameState.players[selfId];
            let cx = p.gridX;
            let cy = p.gridY;

            // è¾¹ç•Œæ£€æŸ¥
            if (dir === 'up' && cy <= 0) return failMove();
            if (dir === 'down' && cy >= gridSize - 1) return failMove();
            if (dir === 'left' && cx <= 0) return failMove();
            if (dir === 'right' && cx >= gridSize - 1) return failMove();

            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæœ¬åœ°ç¢°æ’æ£€æµ‹
            // å¿…é¡»æ£€æŸ¥å½“å‰æ ¼å­çš„å¢™å£ï¼Œç¡®è®¤æ²¡æœ‰å¢™æ‰èƒ½èµ°
            let cell = gameState.maze[cy][cx];
            if (!cell) return; // è¿˜æ²¡åŠ è½½å¥½

            let blocked = false;
            if (dir === 'up') blocked = cell.walls.top;
            else if (dir === 'down') blocked = cell.walls.bottom;
            else if (dir === 'left') blocked = cell.walls.left;
            else if (dir === 'right') blocked = cell.walls.right;

            if (blocked) {
                return failMove(); // æ’å¢™äº†ï¼Œä¸èµ°ï¼Œä¸å‘åŒ…
            }

            // é¢„åˆ¤ç§»åŠ¨ (ä¸ºäº†é¡ºæ»‘)
            if (dir === 'up') p.gridY--;
            else if (dir === 'down') p.gridY++;
            else if (dir === 'left') p.gridX--;
            else if (dir === 'right') p.gridX++;

            lastMoveTime = now; // æ›´æ–°æ—¶é—´æˆ³
            socket.emit('playerMoveAction', dir);
            
            // æˆåŠŸçš„å¾®éœ‡åŠ¨
            if(navigator.vibrate) navigator.vibrate(10);
        }

        function failMove() {
            // æ’å¢™åé¦ˆ (ç¨å¾®å¼ºä¸€ç‚¹çš„éœ‡åŠ¨)
            if(navigator.vibrate) navigator.vibrate(30);
        }

        // --- æ‰‹åŠ¿ä¸æŒ‰é”® ---
        let touchStartX = 0, touchStartY = 0;
        document.body.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.body.addEventListener('touchmove', e => e.preventDefault(), {passive: false});

        document.body.addEventListener('touchend', e => {
            let dx = e.changedTouches[0].screenX - touchStartX;
            let dy = e.changedTouches[0].screenY - touchStartY;
            if(Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                if(Math.abs(dx) > Math.abs(dy)) attemptMove(dx > 0 ? 'right' : 'left');
                else attemptMove(dy > 0 ? 'down' : 'up');
            }
        });

        const bindKey = (id, dir) => {
            let btn = document.getElementById(id);
            // æ”¯æŒé•¿æŒ‰ï¼šä½¿ç”¨ setInterval æ¨¡æ‹Ÿè¿å‘ (ç®€å•æ–¹æ¡ˆ)
            // æ›´å¥½çš„æ–¹æ¡ˆæ˜¯ç›‘å¬ touchstart/end é…åˆ requestAnimationFrameï¼Œ
            // ä½†è¿™é‡Œç›´æ¥å¤ç”¨ attemptMove çš„æ—¶é—´èŠ‚æµå³å¯ï¼Œæ‰€ä»¥åªéœ€é«˜é¢‘è§¦å‘ã€‚
            let intervalId = null;
            
            const startMove = (e) => {
                e.preventDefault(); e.stopPropagation();
                btn.style.background = '#f1c40f'; btn.style.color = '#000';
                attemptMove(dir); // ç«‹å³è§¦å‘ä¸€æ¬¡
                // å¼€å¯è¿å‘
                intervalId = setInterval(() => attemptMove(dir), 50); 
            };
            
            const stopMove = (e) => {
                if(e) { e.preventDefault(); e.stopPropagation(); }
                btn.style.background = 'rgba(255,255,255,0.15)'; btn.style.color = '#fff';
                clearInterval(intervalId);
            };

            btn.addEventListener('touchstart', startMove);
            btn.addEventListener('touchend', stopMove);
            btn.addEventListener('mousedown', startMove); // å…¼å®¹é¼ æ ‡ç‚¹å‡»
            btn.addEventListener('mouseup', stopMove);
            btn.addEventListener('mouseleave', stopMove);
        };
        
        bindKey('vb-up', 'up'); bindKey('vb-down', 'down');
        bindKey('vb-left', 'left'); bindKey('vb-right', 'right');

        // ğŸ”¥ ä¿®å¤3ï¼šç”µè„‘ç«¯é”®ç›˜æ”¯æŒé•¿æŒ‰
        let keysPressed = {};
        document.addEventListener('keydown', e => {
            if(['w','a','s','d','ArrowUp','ArrowLeft','ArrowRight','ArrowDown'].includes(e.key)) {
                keysPressed[e.key] = true;
            }
        });
        document.addEventListener('keyup', e => {
            keysPressed[e.key] = false;
        });

        // åœ¨æ¸¸æˆå¾ªç¯ä¸­æ£€æŸ¥æŒ‰é”®ï¼Œå®ç°å¹³æ»‘é•¿æŒ‰ç§»åŠ¨
        function checkKeyboard() {
            if(keysPressed['w'] || keysPressed['ArrowUp']) attemptMove('up');
            if(keysPressed['s'] || keysPressed['ArrowDown']) attemptMove('down');
            if(keysPressed['a'] || keysPressed['ArrowLeft']) attemptMove('left');
            if(keysPressed['d'] || keysPressed['ArrowRight']) attemptMove('right');
        }

        // Socket
        socket.on('connect', () => { connStatus.innerText = "å·²è¿æ¥"; connStatus.style.color = '#2ecc71'; });
        socket.on('disconnect', () => { connStatus.innerText = "æ–­å¼€"; connStatus.style.color = '#e74c3c'; });
        socket.on('init', d => { selfId = d.selfId; gameState = d.gameState; gridSize = d.gridSize; resize(); });
        socket.on('newPlayer', p => { gameState.players[p.id] = p; });
        socket.on('playerMoved', d => { 
            if(gameState.players[d.id]) { 
                gameState.players[d.id].gridX = d.gridX; 
                gameState.players[d.id].gridY = d.gridY; 
            } 
        });
        socket.on('playerDisconnected', id => { delete gameState.players[id]; delete playersRender[id]; });
        socket.on('gameWon', d => {
            let name = (d.winnerId === selfId) ? "ä½ " : "å¯¹æ‰‹";
            document.getElementById('win-text').innerText = `${name} èµ¢äº†!`;
            msgOverlay.style.opacity = 1;
        });
        socket.on('gameRestart', newState => { gameState = newState; msgOverlay.style.opacity = 0; });

        window.onresize = resize;
        
        // å¯åŠ¨å¾ªç¯
        function mainLoop() {
            checkKeyboard(); // æ¯ä¸€å¸§æ£€æŸ¥é”®ç›˜
            draw();
            requestAnimationFrame(mainLoop);
        }
        mainLoop();

    </script>
</body>
</html>