<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>深渊迷宫 - Survival</title>
    <style>
        :root { --ui-bg: rgba(20, 20, 30, 0.9); --accent: #00f3ff; --danger: #ff3366; }
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; user-select: none; touch-action: none; }
        
        canvas { display: block; position: absolute; top: 0; left: 0; }

        /* UI */
        #ui { position: absolute; inset: 0; pointer-events: none; padding: 15px; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        /* 顶部信息 */
        .top-row { display: flex; justify-content: space-between; align-items: flex-start; }
        .radar { 
            width: 120px; height: 120px; background: rgba(0,0,0,0.8); 
            border: 2px solid #444; border-radius: 50%; overflow: hidden; position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #mini { width: 100%; height: 100%; opacity: 0.8; }
        
        .info { text-align: right; background: var(--ui-bg); padding: 10px; border-radius: 4px; border-right: 3px solid var(--accent); }
        .info div { margin-bottom: 4px; color: #ccc; font-size: 12px; }
        .val { color: #fff; font-weight: bold; margin-left: 5px; }

        /* 调试信息 */
        #debug-info {
            position: absolute; top: 50px; left: 10px; 
            color: #555; font-size: 10px; background: rgba(0,0,0,0.5); padding: 5px;
            pointer-events: auto;
        }

        /* 底部能量 */
        .btm-row { width: 100%; max-width: 400px; align-self: center; margin-bottom: 40px; }
        .bar-box { height: 14px; background: #222; border: 1px solid #555; border-radius: 7px; overflow: hidden; padding: 2px; }
        .bar { height: 100%; width: 100%; background: var(--accent); border-radius: 5px; transition: width 0.2s, background 0.3s; box-shadow: 0 0 10px var(--accent); }
        .bar-label { text-align: center; color: #777; font-size: 10px; margin-top: 4px; letter-spacing: 2px; }

        /* 死亡 */
        #dead-screen {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 20;
            display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto;
        }
        .dead-title { font-size: 40px; color: var(--danger); font-weight: bold; margin-bottom: 20px; text-shadow: 0 0 20px var(--danger); }
        button { background: transparent; border: 2px solid #fff; color: #fff; padding: 10px 30px; font-size: 16px; cursor: pointer; }
        button:active { background: #fff; color: #000; }

        /* 触控 */
        #pads { position: absolute; bottom: 20px; left: 20px; display: grid; grid-template-columns: repeat(3,60px); grid-template-rows: repeat(3,60px); gap:5px; pointer-events: auto; opacity: 0.5; }
        .btn { background: rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius: 10px; color: #fff; display:flex; justify-content:center; align-items:center; font-size: 24px;}
        .btn:active { background: rgba(255,255,255,0.3); }
        .u { grid-column:2; grid-row:1 } .l { grid-column:1; grid-row:2 } .r { grid-column:3; grid-row:2 } .d { grid-column:2; grid-row:3 }
    </style>
</head>
<body>

    <canvas id="game"></canvas>

    <div id="ui">
        <div class="top-row">
            <div class="radar">
                <canvas id="mini"></canvas>
            </div>
            <div class="info">
                <div>SCORE <span class="val" id="score">0</span></div>
                <div>POS <span class="val" id="coords">0, 0</span></div>
                <div id="status" style="color:var(--accent)">SYSTEM ONLINE</div>
            </div>
        </div>

        <div id="debug-info">Waiting for server...</div>

        <div class="btm-row">
            <div class="bar-box"><div class="bar" id="energy"></div></div>
            <div class="bar-label">ENERGY LEVEL</div>
        </div>

        <div id="pads">
            <div class="btn u" data-d="up">▲</div>
            <div class="btn l" data-d="left">◀</div>
            <div class="btn d" data-d="down">▼</div>
            <div class="btn r" data-d="right">▶</div>
        </div>
    </div>

    <div id="dead-screen">
        <div class="dead-title">SIGNAL LOST</div>
        <button onclick="respawn()">REBOOT</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io('/maze');
        const cvs = document.getElementById('game');
        const ctx = cvs.getContext('2d');
        const mcvs = document.getElementById('mini');
        const mctx = mcvs.getContext('2d');
        const debugEl = document.getElementById('debug-info');

        // 配置
        let config = { CELL_SIZE: 40, CHUNK_SIZE: 15 };
        let me = { x: 0, y: 0, energy: 100, isDead: false, score: 0 };
        // 插值坐标
        let rPos = { x: 0, y: 0 }; 
        let cam = { x: 0, y: 0 };
        
        let chunks = {};
        let players = {};
        let selfId = null;
        let connected = false;

        function resize() {
            cvs.width = window.innerWidth;
            cvs.height = window.innerHeight;
            mcvs.width = 120; mcvs.height = 120;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Socket ---
        socket.on('connect', () => {
            debugEl.innerText = "Connected. Waiting for data...";
        });

        socket.on('init', (data) => {
            selfId = data.selfId;
            config = data.config;
            connected = true;
            debugEl.innerText = "Initialized. ID: " + selfId.substr(0,4);
        });

        socket.on('gamestate', (state) => {
            if(!connected) return;
            
            // 更新地图
            state.chunks.forEach(c => chunks[`${c.cx},${c.cy}`] = c);
            
            // 更新玩家
            players = state.players;
            me = state.me;

            // 第一次同步坐标，避免飞跃
            if (rPos.x === 0 && rPos.y === 0 && me) {
                rPos.x = me.x * config.CELL_SIZE;
                rPos.y = me.y * config.CELL_SIZE;
            }

            updateUI(state.leaderboard);
        });

        socket.on('item_removed', (d) => {
            if(chunks[d.key]) chunks[d.key].items = chunks[d.key].items.filter(i=>i.id!==d.id);
        });

        function respawn() { socket.emit('respawn'); }

        function updateUI(lb) {
            // 能量
            const pct = Math.max(0, me.energy);
            const bar = document.getElementById('energy');
            bar.style.width = pct + '%';
            if(pct < 30) bar.style.background = '#ff3366';
            else if(pct < 60) bar.style.background = '#f1c40f';
            else bar.style.background = '#00f3ff';

            // 文字
            document.getElementById('score').innerText = Math.floor(me.score);
            document.getElementById('coords').innerText = `${Math.floor(me.x)},${Math.floor(me.y)}`;
            
            // 死亡
            document.getElementById('dead-screen').style.display = me.isDead ? 'flex' : 'none';
            document.getElementById('status').innerText = me.isDead ? "CRITICAL FAILURE" : "OPERATIONAL";
            document.getElementById('status').style.color = me.isDead ? "red" : "#00f3ff";
        }

        // --- 渲染循环 ---
        function loop() {
            requestAnimationFrame(loop);

            // 1. 清屏 (深蓝黑背景)
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, cvs.width, cvs.height);

            if (!connected || !selfId) {
                // 如果没连上，画个网格表示程序活着
                drawGrid(0, 0);
                return;
            }

            // 2. 计算插值位置 (平滑移动)
            let tx = me.x * config.CELL_SIZE;
            let ty = me.y * config.CELL_SIZE;
            
            // 简单的线性插值
            rPos.x += (tx - rPos.x) * 0.2;
            rPos.y += (ty - rPos.y) * 0.2;

            // 3. 计算摄像机 (以玩家为中心)
            cam.x = Math.floor(rPos.x + config.CELL_SIZE/2 - cvs.width/2);
            cam.y = Math.floor(rPos.y + config.CELL_SIZE/2 - cvs.height/2);

            // --------------------
            // 进入世界坐标
            // --------------------
            ctx.save();
            ctx.translate(-cam.x, -cam.y);

            // A. 背景网格
            drawGrid(cam.x, cam.y);

            // B. 迷宫墙壁
            drawMaze();

            // C. 玩家
            drawPlayers();

            ctx.restore(); 
            // 退出世界坐标
            // --------------------

            // 4. 迷雾 (最稳健的剪纸法)
            drawFogSolid();

            // 5. 小地图
            drawMini();
        }

        function drawGrid(cx, cy) {
            ctx.strokeStyle = '#1a1a20';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            const cs = config.CELL_SIZE;
            // 算出屏幕覆盖的网格范围
            const sx = Math.floor(cx / cs) * cs;
            const sy = Math.floor(cy / cs) * cs;
            const ex = cx + cvs.width;
            const ey = cy + cvs.height;

            for(let x = sx; x < ex + cs; x += cs) {
                ctx.moveTo(x, cy); ctx.lineTo(x, ey + cs);
            }
            for(let y = sy; y < ey + cs; y += cs) {
                ctx.moveTo(cx, y); ctx.lineTo(ex + cs, y);
            }
            ctx.stroke();
        }

        function drawMaze() {
            // 计算视野内的 Chunk
            const cs = config.CELL_SIZE;
            const cSize = config.CHUNK_SIZE;
            const px = rPos.x + 20; // 玩家中心点
            const py = rPos.y + 20;
            
            const cx = Math.floor(px / (cs * cSize));
            const cy = Math.floor(py / (cs * cSize));

            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#00f3ff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f3ff';

            // 渲染周围 3x3 个区块
            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    let k = `${cx+dx},${cy+dy}`;
                    if(chunks[k]) drawChunk(chunks[k]);
                }
            }
            ctx.shadowBlur = 0;
        }

        function drawChunk(chunk) {
            const cs = config.CELL_SIZE;
            const ox = chunk.cx * config.CHUNK_SIZE * cs;
            const oy = chunk.cy * config.CHUNK_SIZE * cs;

            ctx.beginPath();
            chunk.grid.forEach(row => {
                row.forEach(c => {
                    let x = ox + c.x * cs;
                    let y = oy + c.y * cs;
                    if(c.walls.top) { ctx.moveTo(x,y); ctx.lineTo(x+cs,y); }
                    if(c.walls.left) { ctx.moveTo(x,y); ctx.lineTo(x,y+cs); }
                    if(c.walls.right && c.x===config.CHUNK_SIZE-1) { ctx.moveTo(x+cs,y); ctx.lineTo(x+cs,y+cs); }
                    if(c.walls.bottom && c.y===config.CHUNK_SIZE-1) { ctx.moveTo(x,y+cs); ctx.lineTo(x+cs,y+cs); }
                });
            });
            ctx.stroke();

            // 物品
            ctx.fillStyle = '#f1c40f';
            ctx.shadowColor = '#f1c40f';
            ctx.shadowBlur = 10;
            chunk.items.forEach(item => {
                let ix = ox + item.x * cs + cs/2;
                let iy = oy + item.y * cs + cs/2;
                ctx.beginPath();
                ctx.arc(ix, iy, 4, 0, Math.PI*2); // 简单的发光圆点
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function drawPlayers() {
            for(let id in players) {
                let p = players[id];
                if(p.isDead) continue;

                let x, y;
                if(id === selfId) {
                    x = rPos.x + 20; 
                    y = rPos.y + 20;
                } else {
                    x = p.x * config.CELL_SIZE + 20;
                    y = p.y * config.CELL_SIZE + 20;
                }

                ctx.shadowBlur = 15;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI*2);
                ctx.fill();

                if(id === selfId) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 0;
                    ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        // --- 核心修复：剪纸法迷雾 ---
        function drawFogSolid() {
            // 使用“奇偶规则” (evenodd) 填充：
            // 画一个全屏矩形，再画一个反向的圆，重叠部分会被“扣除”
            
            ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // 纯黑
            ctx.beginPath();
            // 1. 全屏矩形 (顺时针)
            ctx.rect(0, 0, cvs.width, cvs.height);
            
            // 2. 视野圆 (逆时针 - 重要！)
            // 视野圆心就是屏幕中心
            const cx = cvs.width / 2;
            const cy = cvs.height / 2;
            const r = config.CELL_SIZE * 6; // 视野半径

            ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
            
            // 3. 填充 (奇偶规则会使得圆内部不填充)
            ctx.fill('evenodd');

            // 4. 加个半透明边缘让过渡自然点 (可选)
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 40;
            ctx.beginPath();
            ctx.arc(cx, cy, r + 20, 0, Math.PI*2);
            ctx.stroke();
        }

        function drawMini() {
            mctx.fillStyle = '#000';
            mctx.fillRect(0,0,120,120);
            
            if(!me) return;
            
            const range = 30; // 范围
            const scale = 120 / range;
            const cx = me.x;
            const cy = me.y;

            for(let id in players) {
                let p = players[id];
                if(p.isDead) continue;
                let dx = p.x - cx;
                let dy = p.y - cy;
                if(Math.abs(dx) < range/2 && Math.abs(dy) < range/2) {
                    mctx.fillStyle = (id===selfId) ? '#fff' : p.color;
                    mctx.fillRect(60 + dx*scale - 2, 60 + dy*scale - 2, 4, 4);
                }
            }
        }

        // --- 控制 ---
        let lastTime = 0;
        function move(d) {
            if(me.isDead) return;
            let now = Date.now();
            if(now - lastTime > 80) {
                lastTime = now;
                socket.emit('move', d);
            }
        }

        window.addEventListener('keydown', e => {
            let k = e.key.toLowerCase();
            if(['w','arrowup'].includes(k)) move('up');
            if(['s','arrowdown'].includes(k)) move('down');
            if(['a','arrowleft'].includes(k)) move('left');
            if(['d','arrowright'].includes(k)) move('right');
        });

        document.querySelectorAll('.btn').forEach(b => {
            const d = b.dataset.d;
            const h = (e) => { e.preventDefault(); move(d); };
            b.addEventListener('touchstart', h);
            b.addEventListener('mousedown', h);
        });

        // 启动渲染
        loop();

    </script>
</body>
</html>