<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>è¿·å®«å¤§ä½œæˆ˜ (Proç‰ˆ)</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; background: #1a1a1a; color: #fff; overflow: hidden; touch-action: none; width: 100vw; height: 100vh; display: flex; font-family: 'Segoe UI', sans-serif;}
        
        #portrait-warning { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; flex-direction: column; justify-content: center; align-items: center; }
        @media screen and (orientation: portrait) { #portrait-warning { display: flex; } #game-ui { display: none !important; } }

        #game-ui { display: flex; width: 100%; height: 100%; padding: 10px; justify-content: space-between; }
        .control-area { flex: 1; display: flex; justify-content: center; align-items: center; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(3, 70px); gap: 8px; }
        .btn { background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; display: flex; justify-content: center; align-items: center; font-size: 30px; color: #ddd; backdrop-filter: blur(4px); transition: 0.1s; }
        .btn:active { background: #f1c40f; color: #000; transform: scale(0.95); }
        #btn-up { grid-column: 2; grid-row: 1; } #btn-left { grid-column: 1; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; } #btn-down { grid-column: 2; grid-row: 3; }

        #canvas-wrapper { flex: 2; background: #000; border: 4px solid #444; border-radius: 10px; margin: 0 20px; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 30px rgba(0,0,0,0.6); position: relative; }
        canvas { display: block; image-rendering: pixelated; }

        .back-btn { position: fixed; top: 15px; left: 15px; padding: 8px 15px; background: #e74c3c; border-radius: 20px; font-size: 14px; z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.3); font-weight: bold; }

        /* ğŸ† èƒœåˆ©æç¤ºå±‚ */
        #win-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 200;
            flex-direction: column; justify-content: center; align-items: center;
            animation: fadeIn 0.3s;
        }
        #win-overlay h1 { font-size: 40px; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin-bottom: 10px; }
        #win-overlay p { font-size: 20px; color: #fff; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="portrait-warning"><h2 style="color:#f1c40f;">ğŸ“± è¯·æ—‹è½¬æ‰‹æœº</h2></div>
    
    <div id="win-overlay">
        <h1>ğŸ‘‘ èƒœåˆ©ï¼</h1>
        <p id="winner-name">ç©å®¶ XXX åˆ°è¾¾äº†ç»ˆç‚¹</p>
        <p style="font-size: 14px; color: #aaa; margin-top: 20px;">3ç§’åå¼€å§‹æ–°èµ›å­£...</p>
    </div>

    <div class="back-btn" onclick="location.href='../index.html'">â¬… è¿”å›å¤§å…</div>

    <div id="game-ui">
        <div class="control-area">
            <div class="d-pad">
                <div class="btn" id="btn-up">â–²</div>
                <div class="btn" id="btn-left">â—€</div>
                <div class="btn" id="btn-right">â–¶</div>
                <div class="btn" id="btn-down">â–¼</div>
            </div>
        </div>
        <div id="canvas-wrapper"><canvas id="gameCanvas"></canvas></div>
        <div class="control-area" style="flex-direction: column; font-size: 14px; color: #aaa;">
            <p>ä½ çš„æœºä½“</p>
            <div id="my-color" style="width:50px; height:50px; border-radius:50%; border:4px solid #fff; box-shadow: 0 0 15px rgba(255,255,255,0.3);"></div>
            <p style="margin-top: 20px; color: #2ecc71;">ç›®æ ‡ï¼šç»¿è‰²æ–¹å—</p>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ==============================================
        // âš ï¸ã€æ‰“åŒ…APPå¿…æ”¹ã€‘âš ï¸
        // ==============================================
        const socket = io('/maze'); 

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');
        const winOverlay = document.getElementById('win-overlay');
        
        let gameState = { maze: [], players: {}, startPoint: {}, endPoint: {} };
        let selfId = null, gridSize = 20, CELL_SIZE = 20;

        function resize() {
            if(!wrapper.clientWidth) return;
            const size = Math.min(wrapper.clientWidth, wrapper.clientHeight) - 20;
            CELL_SIZE = Math.floor(size / gridSize);
            canvas.width = CELL_SIZE * gridSize;
            canvas.height = CELL_SIZE * gridSize;
            draw();
        }

        function draw() {
            if(!gameState.maze.length) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ç”»è¿·å®«å¢™
            ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.lineCap = 'square'; ctx.beginPath();
            for(let y=0; y<gridSize; y++) {
                for(let x=0; x<gridSize; x++) {
                    let c = gameState.maze[y][x], px=x*CELL_SIZE, py=y*CELL_SIZE;
                    if(c.walls.bottom) { ctx.moveTo(px, py+CELL_SIZE); ctx.lineTo(px+CELL_SIZE, py+CELL_SIZE); }
                    if(c.walls.right) { ctx.moveTo(px+CELL_SIZE, py); ctx.lineTo(px+CELL_SIZE, py+CELL_SIZE); }
                    if(y===0 && c.walls.top) { ctx.moveTo(px, py); ctx.lineTo(px+CELL_SIZE, py); }
                    if(x===0 && c.walls.left) { ctx.moveTo(px, py); ctx.lineTo(px, py+CELL_SIZE); }
                }
            }
            ctx.stroke();

            // 2. ç”»ç»ˆç‚¹ (ç»¿è‰²å‘å…‰æ ¼å­)
            if(gameState.endPoint) {
                let ex = gameState.endPoint.x * CELL_SIZE;
                let ey = gameState.endPoint.y * CELL_SIZE;
                ctx.fillStyle = 'rgba(46, 204, 113, 0.4)'; // åŠé€æ˜ç»¿
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex+2, ey+2, CELL_SIZE-4, CELL_SIZE-4);
            }

            // 3. ç”»ç©å®¶
            for(let id in gameState.players) {
                let p = gameState.players[id];
                // å¢åŠ å¹³æ»‘è¿‡æ¸¡æ•ˆæœ (ç®€å•çš„æ’å€¼å¯ä»¥åç»­åŠ ï¼Œè¿™é‡Œå…ˆç›´æ¥æ¸²æŸ“)
                let cx = p.gridX * CELL_SIZE + CELL_SIZE/2;
                let cy = p.gridY * CELL_SIZE + CELL_SIZE/2;
                
                ctx.fillStyle = p.color; ctx.beginPath();
                ctx.arc(cx, cy, CELL_SIZE*0.35, 0, Math.PI*2); ctx.fill();
                if(id === selfId) { ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.stroke(); }
            }
        }

        // ğŸ® ä¸“ä¸šç‰ˆç§»åŠ¨ï¼šåªå‘æŒ‡ä»¤ï¼Œä¸å‘åæ ‡
        function sendMove(dir) {
            // å‰ç«¯å…ˆåšä¸ªç®€å•çš„é¢„åˆ¤ï¼ˆClient Predictionï¼‰ï¼Œè®©æ‰‹æ„Ÿä¸å¡é¡¿
            // ä½†å¦‚æœæ’å¢™äº†ï¼Œè¿˜æ˜¯ä»¥æœåŠ¡å™¨è¿”å›ä¸ºå‡†
            // ä¸ºäº†ä»£ç ç®€æ´ï¼Œè¿™é‡Œæˆ‘ä»¬ç›´æ¥å‘æŒ‡ä»¤ï¼Œç­‰å¾…æœåŠ¡å™¨å¹¿æ’­å›æ¥å†æ¸²æŸ“
            // å±€åŸŸç½‘ä¸‹å»¶è¿Ÿæä½ï¼Œå‡ ä¹æ„Ÿè§‰ä¸åˆ°å¡é¡¿
            socket.emit('playerMoveAction', dir);
        }

        // === Socket äº‹ä»¶ç›‘å¬ ===
        socket.on('init', d => {
            selfId = d.selfId;
            gameState = d.gameState;
            gridSize = d.gridSize;
            resize();
            if(gameState.players[selfId]) document.getElementById('my-color').style.background = gameState.players[selfId].color;
            winOverlay.style.display = 'none'; // éšè—èƒœåˆ©å¼¹çª—
        });

        socket.on('newPlayer', p => { gameState.players[p.id] = p; draw(); });
        
        // ç›‘å¬ç§»åŠ¨ (è¿™æ˜¯æœåŠ¡å™¨ç¡®è®¤åçš„ä½ç½®)
        socket.on('playerMoved', d => {
            if(gameState.players[d.id]) {
                gameState.players[d.id].gridX = d.gridX;
                gameState.players[d.id].gridY = d.gridY;
                draw();
            }
        });

        socket.on('playerDisconnected', id => { delete gameState.players[id]; draw(); });

        // ğŸ‰ ç›‘å¬èƒœåˆ©
        socket.on('gameWon', d => {
            let winner = gameState.players[d.winnerId];
            let name = (d.winnerId === selfId) ? "ä½ " : "å¯¹æ‰‹";
            document.getElementById('winner-name').innerText = `${name} èµ¢äº†ï¼`;
            document.getElementById('winner-name').style.color = winner.color;
            winOverlay.style.display = 'flex';
        });

        // ğŸ”„ ç›‘å¬é‡å¼€
        socket.on('gameRestart', newState => {
            gameState = newState;
            winOverlay.style.display = 'none';
            draw();
        });

        // ç»‘å®šæ“ä½œ
        window.onresize = resize;
        window.addEventListener('orientationchange', () => setTimeout(resize, 500));
        
        const bind = (id, dir) => {
            let b = document.getElementById(id);
            let action = (e) => { e.preventDefault(); sendMove(dir); };
            b.addEventListener('touchstart', action);
            b.addEventListener('mousedown', action);
        };
        bind('btn-up', 'up'); bind('btn-down', 'down');
        bind('btn-left', 'left'); bind('btn-right', 'right');
        
        // é”®ç›˜æ”¯æŒ
        document.addEventListener('keydown', e => {
            if(e.key==='w'||e.key==='ArrowUp') sendMove('up');
            if(e.key==='s'||e.key==='ArrowDown') sendMove('down');
            if(e.key==='a'||e.key==='ArrowLeft') sendMove('left');
            if(e.key==='d'||e.key==='ArrowRight') sendMove('right');
        });
    </script>
</body>
</html>